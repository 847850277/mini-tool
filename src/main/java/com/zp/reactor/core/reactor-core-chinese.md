# reactor-core 中文翻译

## 2 开始

### 2.1. 介绍Reactor

Reactor是 JVM 的一个完全非阻塞的响应式编程基础，具有高效的需求管理(以管理“反压力”的形式)。
它直接与 Java8函数 API 集成，特别是 CompletableFuture、 Stream 和 Duration。
它提供了可组合的异步序列 API ーー `Flux` (用于[ N ]元素)和 `Mono` (用于[0 | 1]元素)ーー并广泛实现了 `Reactive Streams` 规范

### 2.2. 先决条件

ReactCore 在 Java8及以上版本上运行。



## 3 响应式编程入门

Reactor是响应式编程范式的一种实现，可以总结如下:
`响应式编程是一个异步的编程范型，关注数据流和变化的传播。这意味着可以通过所使用的编程语言轻松地表达静态(例如数组)或动态(例如事件发射器)数据流` 维基百科的说明

作为朝着响应式编程方向迈出的第一步，微软在。NET 生态系统。
然后 `RxJava` 在 JVM 上实现了响应式编程。随着时间的推移，通过 `Reactive Streams` 工作出现了 Java 的标准化，这个规范为 JVM 上的反应库定义了一组接口和交互规则。
它的接口已经在 `Flow` 类下集成到 Java9中。


响应式编程模式通常以面向对象语言的形式出现，作为 `Observer` 设计模式的一个扩展。
你还可以将主要的反应流模式与熟悉的 `Iterator` 设计模式进行比较，因为所有这些库中都存在 Iterable-Iterator 对的对偶性。
一个主要的区别是，虽然 Iterator 是基于拉的，但是反应流是基于推的


使用迭代器是一种命令式编程模式，尽管访问值的方法完全是 `Iterable` 的责任。
实际上，由开发人员选择何时访问序列中的下一个()项。在反应流中，上述对的等价物是 `Publisher-Subscriber`。
但是发布服务器在新的可用值出现时通知订阅服务器，而这种推方面是被反应的关键。
此外，应用于推送值的操作以声明方式表示，而不是命令方式表示: 程序员表示计算的逻辑，而不是描述其确切的控制流


除了推送值之外，还以定义良好的方式涵盖了错误处理和完成方面。
发布服务器可以将新值推送到其订阅服务器(通过调用 `onNext`) ，但也可以发出错误信号(通过调用 `onError`)或完成信号(通过调用 `onComplete`)。
错误和完成都会终止序列。这可以总结如下

```java

onNext x 0..N [onError | onComplete]

```

这种方法非常灵活。该模式支持没有值、一个值或 n 个值的用例(包括无限的值序列，例如时钟的持续滴答声)。

但是为什么我们首先需要这样一个异步反应库呢？


### 3.1. 阻塞可能是浪费

现代应用程序可以达到大量的并发用户，而且，即使现代硬件的能力不断提高，现代软件的性能仍然是一个关键问题。

总的来说，有两种方法可以提高程序的性能:

- 并行化以使用更多的线程和更多的硬件资源。
- 在如何使用现有资源方面寻求更高的效率。


通常，Java 开发人员使用阻塞代码编写程序。
在出现性能瓶颈之前，这种做法是可行的。
然后是时候引入额外的线程，运行类似的阻塞代码。
但是，资源利用率的这种扩展可能会迅速引入争用和并发问题


更糟糕的是，阻塞会浪费资源。
如果仔细观察，一旦程序出现延迟(特别是 I/O，比如数据库请求或网络调用) ，资源就会被浪费，因为线程(可能有许多线程)现在处于空闲状态，等待数据

因此，并行化方法并不是万能的。
硬件的全功能访问是必要的，但是资源浪费的原因很复杂，也很容易造成资源浪费。

### 3.2. 异步就是解药吗？

前面提到的第二种方法，寻求更高的效率，可以解决资源浪费问题。
通过编写异步、非阻塞代码，可以让执行切换到使用相同底层资源的另一个活动任务，然后在异步处理完成后返回到当前进程

但是如何在 JVM 上生成异步代码呢? Java 提供了两种异步编程模型:
- 回调: 异步方法没有返回值，但是接受一个额外的回调参数(lambda 或匿名类) ，当结果可用时调用该参数。一个著名的例子是 `Swing` 的 `EventListener` 层次结构。
- `Futures`: 异步方法立即返回 `Future < T >` 。异步进程计算一个 T 值，但 Future 对象包装对它的访问。该值不会立即可用，并且可以轮询该对象，直到该值可用为止。例如，运行 `Callable < T >` 任务的 `ExecutorService` 使用 Future 对象。

这些技术是否足够好? 不是每个用例都适用，而且两种方法都有局限性。

回调很难组合在一起，很快就会导致难以阅读和维护的代码(称为`回调地狱`)。

Reactor 对比 `回调`和`Futures` 更加方便和更好使用。具体参见官方文档点的例子

### 3.3. 从命令到响应式编程

反应式库(比如 `Reactor`)旨在解决 JVM 上“经典”异步方法的这些缺点，同时也关注一些其他方面:
- 可组合性和可读性
- 数据作为具有丰富的操作符词汇表的流进行操作
- 除非你订阅，否则什么都不会发生
- 背压或消费者向生产者发出排放率过高的信号的能力
- 不可并发的高级但高值抽象

#### 3.3.1. 可组合性和可读性

通过“可组合性”，我们指的是编排多个异步任务的能力，在这种能力中，我们使用来自先前任务的结果来将输入提供给后续任务。
或者，我们可以以 `fork-join` 风格运行多个任务。此外，我们还可以将异步任务重用为高级系统中的离散组件。

编排任务的能力与代码的可读性和可维护性密切相关。
随着异步进程的层数和复杂度的增加，编写和读取代码变得越来越困难。
正如我们所看到的，回调模型很简单，但是它的一个主要缺点是，对于复杂的进程，你需要从回调执行回调，它本身嵌套在另一个回调中，以此类推
。那个烂摊子被称为“二次地狱”。正如你可以猜测(或从经验中了解到)的那样，这样的代码是非常难以回去推理的

`Reactor` 提供了丰富的组合选项，其中代码反映了抽象过程的组织，并且所有内容通常都保持在相同的级别(嵌套最小化)。


#### 3.3.2. 流水线类比


你可以将反应式应用程序处理的数据视为在装配线中移动。
反应器既是传送带又是工作站。原材料从源头(`原始发布者`)倾泻而出，最终成为成品，准备推送给消费者(`或订阅者`)。

原材料可以经历各种转换和其他中间步骤，或者成为将中间件聚集在一起的较大装配线的一部分。
如果在某一点出现故障或堵塞(可能装箱产品需要不成比例的长时间) ，受影响的工作站可以向上游发出信号，以限制原材料的流动。


#### 3.3.3. 接线员

在Reactor中，操作员就是我们组装类比中的工作站。
每个操作符都将行为添加到发布服务器，并将上一步骤的发布服务器封装到新实例中。
因此，整个链是连接的，数据从第一个发布服务器发出，并沿着链向下移动，通过每个链进行转换。
最终，订阅服务器完成该过程。
请记住，在订阅服务器订阅发布服务器之前不会发生任何事情，我们将很快看到这一点

虽然 `Reactive Streams` 规范根本没有指定操作符，但是反应库(比如 `Reactor)`的最佳附加值之一是它们提供的丰富的操作符词汇表。
它们涵盖了很多领域，从简单的转换和过滤到复杂的编排和错误处理。

#### 3.3.4. 除非你订阅，否则什么也不会发生

在Reactor中，当你编写`Publisher chain`时，默认情况下数据不会开始输入到发布服务器链中。
相反，您可以创建异步流程的抽象描述(这有助于提高可重用性和组合性)。


通过订阅，你将`Publisher`绑定到`Subscriber`，从而触发整个链中的数据流。
这是通过来自`Subscriber`的`request`信号在内部实现的，该请求信号被传播到上游，一直传播到源`Publisher`。

#### 3.3.5. 背压

上游传播信号也被用来实现背压，我们在装配线类比中将其描述为当工作站处理速度比上游工作站慢时向上发送的反馈信号

`Reactive Streams` 规范定义的真正机制非常类似: 订阅者可以在无限制模式下工作，并让源以最快的速度推送所有数据，或者它可以使用请求机制向源发出信号，表示它最多可以处理 n 个元素。

中间运营商还可以更改传输中的请求。
假设有一个缓冲区操作符，它将元素以10个为一批进行分组。
如果订阅者请求一个缓冲区，则源生成10个元素是可以接受的。
一些操作员还实现了预取策略，这样可以避免请求(1)往返，并且如果在请求之前生成元素的成本不是太高，那么这种策略是有益的


这将推模型转换为 `push-pull hybrid`，下游可以从上游拉 n 个元素，如果它们容易获得的话。
但是，如果元素还没有准备好，它们就会被上游推动，无论何时生产


#### 3.3.6. 冷热对决

Rx 反应文库家族区分了两大类反应序列: 热反应和冷反应。这种区别主要与反应流如何对订阅者作出反应有关
- 冷序列为每个订阅服务器重新启动，包括在数据源处。例如，如果源包装了一个 HTTP 调用，则为每个订阅发出一个新的 HTTP 请求
- 对于每个订阅服务器，热序列不会从头开始。相反，后期订阅者接收订阅后发出的信号。然而，请注意，一些热反应流可以缓存或重播排放的全部或部分历史。从一般的角度来看，当没有订阅者在监听时，热序列甚至可以发出(“在订阅之前什么都没有发生”规则的一个例外)。


## 4 Reactor Core 特性

Reactor项目的主要工件是Reactor Core，这是一个关注于反应流规范并以 Java8为目标的反应库。

反应器引入了可组合的反应类型，它们实现 `Publisher`，但也提供了丰富的操作员词汇表: `Flux` 和 `Mono`。`Flux` 对象表示反应序列0。.而 `Mono` 对象表示单值或空(0。。1)结果。

这种区别在类型中带有一点语义信息，表明异步处理的粗略基数。
例如，一个 `HTTP` 请求只产生一个响应，因此执行计数操作没有多大意义
。因此，将这样一个 `HTTP` 调用的结果表示为 `Mono < HttpResponse >` 比将其表示为 `Flux < HttpResponse >` 更有意义，因为它只提供与零项或一个项的上下文相关的操作符

更改处理的最大基数的运算符也会切换到相关类型。例如，count 操作符存在于 `Flux` 中，但它返回 `Mono < Long >`

### 4.1. Flux, 0-N 项的异步序列

`Flux < T >` 是一个标准的 `Publisher < T >` ，表示0到 N 个发出项的异步序列，可以选择由完成信号或错误终止。
与 `Reactive Streams` 规范一样，这三种类型的信号转换为对下游订阅服务器的 `onNext`、 `onComplete` 和 `onError` 方法的调用


对于这种大范围的可能信号，通量是通用的反应类型。
请注意，所有事件，甚至终止事件，都是可选的: 没有 onNext 事件，但是一个 onComplete 事件表示一个空的有限序列，但是删除 onComplete 事件，就会得到一个无限的空序列(除了关于取消的测试之外，不是特别有用)。
类似地，无限序列不一定是空的。
例如，Flux.time (持续时间)产生一个 Flux < Long > ，它是无限的，并且从一个时钟中发出规则的滴答声

### 4.2. Mono, 异步0-1结果

`Mono < T >` 是一个专门的 `Publisher < T >` ，它最多通过 onNext 信号发射一个条目，然后终止为 onComplete 信号(成功的 Mono，有或没有值) ，或者只发射一个 onError 信号(失败的 Mono)

大多数 Mono 实现在调用 onNext 之后都会立即在订阅服务器上调用 onComplete。
Never ()是一个异常值: 它不发出任何信号，这在技术上并没有被禁止，尽管在测试之外并没有特别有用。另一方面，onNext 和 onError 的组合是明确禁止的。

Mono 只提供了 Flux 可用的操作符的一个子集，一些操作符(特别是那些将 Mono 与另一个发布服务器结合起来的操作符)切换到 Flux。
例如，Mono # concatWith (Publisher)返回 Flux，而 Mono # then (Mono)返回另一个 Mono

注意，您可以使用 Mono 来表示只有完成概念的无值异步进程(类似于 Runnable)。要创建一个，您可以使用一个空的 Mono < void > 。

### 4.3. 创建 Mono 和 Flux

```java

Flux<String> seq1 = Flux.just("foo", "bar", "foobar");
List<String> iterable = Arrays.asList("foo", "bar", "foobar");
Flux<String> seq2 = Flux.fromIterable(iterable);


Mono<String> noData = Mono.empty();
Mono<String> data = Mono.just("foo");
Flux<Integer> numbersFromFiveToSeven = Flux.range(5, 7);

```

#### 4.3.1. 订阅的例子

在订阅方面，Flux 和 Mono 使用 Java8 lambdas。你有很多选择。对于不同的回调组合，采用 lambdas 的 sub ()变量，如下面的方法签名所示

```java

subscribe(); 

subscribe(Consumer<? super T> consumer); 

subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer); 

subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer); 

subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer,
          Consumer<? super Subscription> subscriptionConsumer); 


```


#### 4.3.2. 取消订阅

所有这些订阅()的基于 lambda 的变体都有一个 Disposable 返回类型。在这种情况下，Disposable 接口表示可以通过调用订阅的 pose ()方法取消订阅。


对于 Flux 或 Mono，取消是一个信号，表明源应该停止生产元素。然而，不能保证它是立即的: 有些源可能生成元素如此之快，以至于他们甚至可以在收到取消指令之前完成

Disposables 类中提供了一些与 Disposable 相关的实用工具。其中，Disposable.swap ()创建了一个 Disposable 包装器，可以自动取消并替换具体的 Disposable。例如，在 UI 场景中，当用户单击一个按钮时，您希望取消一个请求并用一个新的请求替换它，这可能很有用。处理包装本身会关闭它。这样做将处置当前的具体值和所有未来尝试的替换

另一个有趣的实用程序是 Disposable.Composite (...)。这种组合允许您收集几个 Disposable ーー例如，与一个服务调用相关联的多个正在运行的请求ーー并在以后同时处理所有这些请求。一旦调用了复合函数的 pose ()方法，任何添加另一个 Disposable 的尝试都会立即将其处理掉。


#### 4.3.3. Lambdas 的替代方案: BaseSubscriber

还有一种更通用的附加订阅方法，它采用成熟的订阅服务器，而不是使用 lambdas 组成订阅服务器。为了帮助编写这样的订阅服务器，我们提供了一个名为 BaseSubscriber 的可扩展类


#### 4.3.4. 论反压力与重塑请求的途径


在反应器中实施反压时，消费者压力传播回来源的方式是向上游操作者发送请求。当前请求的总和有时被称为当前“请求”或“挂起的请求”。
需求的上限为 Long.MAX _ VALUE，表示无限制的请求(意思是“尽可能快地生产”ーー基本上禁用反压力)。

第一个请求来自订阅时的最终订阅者，但是最直接的订阅方式都会立即触发一个无限制的 Long.MAX _ VALUE 请求
- 以及它的大多数基于 lambda 的变体(消费者 < 订阅 > 的变体除外)
- block(), blockFirst() and blockLast()
- 遍历 toIterable ()或 toStream ()

自定义原始请求的最简单方法是使用重写了 hookOnSubscribe 方法的 BaseSubscriber 进行订阅，如下面的示例所示:

```java


Flux.range(1, 10)
    .doOnRequest(r -> System.out.println("request of " + r))
    .subscribe(new BaseSubscriber<Integer>() {

      @Override
      public void hookOnSubscribe(Subscription subscription) {
        request(1);
      }

      @Override
      public void hookOnNext(Integer integer) {
        System.out.println("Cancelling after having received " + integer);
        cancel();
      }
    });

```

当操作一个请求时，您必须小心地产生足够的需求以使序列前进，否则您的 Flux 可能会“卡住”。
这就是为什么 `BaseSubscriber` 在 `hookOnSubscribe` 中默认为无限制请求的原因。
当重写此钩子时，通常应该至少调用 request 一次。


改变下游需求的运营商 略，看的不是太懂，具体参见官方文档


### 4.4. 以编程方式创建序列

在本节中，我们通过以编程方式定义相关事件(onNext、 onError 和 onComplete)来介绍 Flux 或 Mono 的创建。
所有这些方法都共享一个事实，即它们公开一个 API 来触发事件,我们称为`sink`。实际上有一些`sink`的变种，我们很快就会讲到

#### 4.4.1. generate 同步创建


最简单的方式就是通过`generate`方法来创建一个`Flux`。

这是一种 同步地， 逐个地 产生值的方法，意味着 `sink` 是一个 `SynchronousSink` 而且其 `next()` 方法在每次回调的时候最多只能被调用一次。
你也可以调用 `error(Throwable)` 或者 `complete()`，不过是可选的


最有用的一种方式就是同时能够记录一个状态值`（state）`，从而在使用 `sink` 发出下一个元素的时候能够 基于这个状态值去产生元素。
此时生成器`（generator）`方法就是一个 `BiFunction<S, SynchronousSink<T>, S>`， 其中` <S> `是状态对象的类型。你需要提供一个` Supplier<S>` 来初始化状态值，而生成器需要 在每一“回合”生成元素后返回新的状态值（供下一回合使用）。



#### 4.4.2. create 方法创建

作为一个更高级的创建 `Flux` 的方式， `create` 方法的生成方式既可以是同步， 也可以是异步的，并且还可以每次发出多个元素。


该方法用到了 `FluxSink`，后者同样提供 next，error 和 complete 等方法。 
与 `generate` 不同的是，`create` 不需要状态值，另一方面，它可以在回调中触发 多个事件(即使是在未来的某个时间)。
- `create` 有个好处就是可以将现有的 API 转为响应式，比如监听器的异步方法。



#### 4.4.3. Handle



### 4.5. 调度器（Schedulers）


